### python 超基础面试题



#### 1. **Python 的特点和优点是什么?**

```
优点:
1. 解释性  2. 动态特性 3,.面向对象 4.语法简洁 5.开源 6.丰富的社区资源
```

#### 2. 深拷贝和浅拷贝的区别是什么

```
深拷贝是将对象本身复制给另一个对象。这意味着如果对对象的副本进行更改时不会影响原对象。在 Python 中，我们使用 deepcopy（）函数进行深拷贝，使用方法如下：
```

#### 3.**列表和元祖有什么不同？**

```
主要区别在于列表是可变的，元祖是不可变的。看下面的例子
... 可以从更深层次的角度进行解读，参考流畅的python
```

#### 4. **解释 Python 中的三元表达式**

```
[on true] if [expression]else [on false]
```

#### 5. **Python 中如何实现多线程？**

```
线程是轻量级的进程，多线程允许一次执行多个线程。众所周知，Python 是一种多线程语言，它有一个多线程包。
GIL（全局解释器锁）确保一次执行单个线程。一个线程保存 GIL 并在将其传递给下一个线程之前执行一些操作，这就产生了并行执行的错觉。但实际上，只是线程轮流在 CPU 上。当然，所有传递都会增加执行的开销。
```

#### 6. **解释继承**

```
一个类继承自另一个类，也可以说是一个孩子类/派生类/子类，继承自父类/基类/超类，同时获取所有的类成员（属性和方法）。
继承使我们可以重用代码，并且还可以更方便地创建和维护代码。Python 支持以下类型的继承：
1. 单继承- 一个子类类继承自单个基类
2. 多重继承- 一个子类继承自多个基类
3. 多级继承- 一个子类继承自一个基类，而基类继承自另一个基类
4. 分层继承- 多个子类继承自同一个基类
5. 混合继承- 两种或两种以上继承类型的组合
```

#### 7.**什么是 Flask？**

```
Flask 是一个使用 Python 编写的轻量级 Web 应用框架，使用 BSD 授权。其 WSGI 工具箱采用 Werkzeug，模板引擎则使用 Jinja2。除了 Werkzeug 和 Jinja2 以外几乎不依赖任何外部库。因为 Flask 被称为轻量级框架。
Flask 的会话会话使用签名 cookie 来允许用户查看和修改会话内容。它会记录从一个请求到另一个请求的信息。但如果要修改会话，则必须有密钥 Flask.secret_key。
```

#### 8. **如何在 Python 中管理内存?**

```
Python 用一个私有堆内存空间来放置所有对象和数据结构，我们无法访问它。由解释器来管理它。不过使用一些核心 API，我们可以访问一些 Python 内存管理工具控制内存分配。
```

#### 9. **解释 Python 中的 help() 函数和 dir() 函数。**

```
help() 函数返回帮助文档和参数说明：
dir() 函数返回对象中的所有成员 (任何类型)
```

#### 10.  **当退出 Python 时是否释放所有内存分配？**

```
答案是否定的。那些具有对象循环引用或者全局命名空间引用的变量，在 Python 退出是往往不会被释放
```

#### **11. 如何随机打乱列表中元素，要求不引用额外的内存空间？**

```
我们用 random 包中的 shuffle() 函数来实现。
[3, 4, 8, 0, 5, 7, 6, 2, 1]
```

#### 12. **如何删除字符串中的前置空格**

```
前置空格是第一个非空格字符前的所有空格，使用 lstrip() 函数来删除.
```

#### 13. **请解释 Python 中的闭包？**

```
如果在一个内部函数里。对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就是一个闭包。
```

#### 14. 可更改类型和不可更改类型

```
python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点)
当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.
```

#### 15. python中的元类

```
pass
```

#### 16.Python自省

```
自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
```

#### 17.AOP概念及作用

```
AOP 即面向切面编程，指扩展功能不修改源代码，将功能代码从业务逻辑代码中分离出来。
主要作用就是将类似于日志记录，性能统计，安全控制，事务处理，异常处理等重复性的代码块从业务逻辑代码中划分出来，对这些行为的分离。并且将它们独立到非知道业务逻辑的方法中，从而做到改变这些行为的时候不影响业务逻辑代码。
```

#### 18. python中的作用域

```
本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）
```

#### 19. Python垃圾回收机制

```
Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。
1 引用计数
PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。

优点:

简单
实时性
缺点:

维护引用计数消耗资源
循环引用
2 标记-清除机制
基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。

3 分代技术
分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。
```

